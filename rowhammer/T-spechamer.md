**高级翻译：**

第 III 节提供的高层描述假设了两个关键前提条件。首先，通过内存模板步骤找到易受翻转的有用地址。接着，内存调整步骤用于强制目标受害变量使用该地址。在本节中，我们描述内存模板化过程，将堆栈调整的描述推迟到第 V 节。模板化的目标是获得“有用”的比特翻转，这意味着它们可以用来修改数组偏移变量并触发 SpecHammer 攻击。比特翻转的脆弱性取决于具体 DIMM 的特性，因此需要锤击多个地址以了解哪些地址包含有用的翻转。模板化过程中使用的技术主要借鉴了现有研究，因此我们保持高层描述，并引导读者参考相关的前期工作 [27], [37]，更详细的说明见附录 A。

**A. 从虚拟地址获取 DRAM 行索引**
 如第 II 节所述，当两个攻击行紧夹受害行并连续锤击时，Rowhammer 的效果会显著增强，这种技术称为双侧锤击 [23]。通过双侧 Rowhammer 寻找翻转需要控制三个连续的 DRAM 行。然而，作为非特权攻击者，我们无法直接确定虚拟页如何映射到 DRAM 行，从而无法执行双侧锤击。因此，我们必须逆向工程此映射才能开始锤击。
 由于虚拟地址映射到物理地址，物理地址再映射到 DRAM 行，我们需要获取虚拟到物理的映射以及物理到 DRAM 的映射。
 对于后者，我们使用 Pessl 的 DRAMA 技术 [37]。对于前者，我们只需获取用于确定相应内存排、银行和通道的物理地址位。对于使用 DDR3 的 Haswell 处理器，这些是最低的 21 位。因此，我们可以使用 RAMBleed [27] 中描述的技术，获得一个连续的 2MiB 页，进而获取最低的 21 位物理地址位。由于此技术依赖于最近被限制的 pagetypeinfo 文件，我们改用一种基于 world-readable buddyinfo 文件的新技术（见附录 A）。使用新的 buddyinfo 技术不会影响此步骤所需的时间。
 对于使用 DDR4 内存的新架构，我们遵循 TRRespass [14] 的方法，使用 Linux 内核版本 5.14（撰写时的最新版本）中默认启用的透明大页。注意，对于单 DIMM 配置，仅需低至第 21 位的地址；对于双 DIMM 配置，可以通过内存调整技术获得 4MB 连续内存。

**B. 锤击内存**
 在将所有获得的内存排序到行后，我们将攻击行和受害行初始化为反映我们期望翻转的值。在本例中，我们试图增加一个数组偏移值以指向机密数据，这意味着我们希望将受害比特从 0 翻转为 1。因此，我们将潜在的受害行初始化为全 0。由于当受害比特被两个相反值的比特夹住时，双侧锤击最有效 [23], [27]，我们将攻击行设置为全 1，从而形成 1-0-1 的攻击-受害-攻击条纹配置。

**诱发翻转**
 如同现有研究和 Rowhammer 模板代码 [16], [44], [50], [54] 中所做的，我们反复从缓存中读取和刷新攻击行，确保每次读取直接访问 DRAM，并对相邻行造成扰动效应。完成固定数量的读取后，我们读取受害行以检查是否发生比特翻转，在本例中，翻转指受害行的值中任何比特被设置为 1。我们保存包含有用翻转的地址（即导致数组偏移指向机密的翻转比特），然后进入内存调整阶段。
 注意，上述步骤未刷新受害地址的缓存行。因此，当我们试图读取受害行以检查是否诱发翻转时，很可能读取的是缓存的初始数据。

**有用翻转的需求**
 运行现有 Rowhammer 代码 [16] 在多个 DDR3 DIMM 上测试时，我们发现翻转率相对较低，每小时约 2 到 5 次翻转。然而，对于我们的 SpecHammer 攻击，我们需要特定的比特翻转（一个 4KiB 页中的单个位位置），以将数组指向机密数据，这意味着在平均情况下找到所需比特会耗费极长时间。一种解决方案是测试许多 DIMM，直到找到一个对 Rowhammer 特别敏感的 DIMM，从而将攻击限制在此类易感 DIMM 上。然而，我们发现现有 Rowhammer 仓库在受害数据缓存问题上存在疏漏，导致易感 DIMM 看起来对翻转具有抵抗性，而实际上，大多数翻转仅仅是因为缓存数据被掩盖了。通过修改这些现有仓库，我们发现同样的 DIMM 每小时会出现数千次翻转，使我们能够在以前认为安全的 DIMM 上执行攻击。

**以往工作的翻转率低报问题**
 在检查多个公共 Rowhammer 仓库 [16], [44], [50], [54]（设计用于测试 DIMM 对 Rowhammer 的脆弱性）时，我们发现它们都存在前述受害行缓存的疏漏。按照上述步骤，读取受害行以检查比特翻转时，可能会读取缓存的初始数据，从而严重低报了在任何测试 DIMM 上可获得的实际翻转数量。报告的任何翻转可能是因为受害数据被其他内存访问意外驱逐出缓存而导致的。在附录 C 中，我们描述了证明缓存效应确实掩盖了比特翻转的实验。

**Rowhammer 技术的比较**
 为了充分理解此疏漏对找到比特翻转的影响，我们将前期工作与我们的受害缓存刷新修改进行了比较。结果显示在表 I 中。我们在两小时内使用 1-0-1 条纹配置进行双侧锤击运行每个程序，然后在两小时内测试 0-1-0 配置。两次运行的总翻转数显示在表中。
 注意，Rowhammer.js [16] 的仓库存在一个错误，该错误在确定哪些地址位于同一内存排时使用了虚拟地址而非物理地址，因此分为两条记录：一个是未修改的 Rowhammer.js，另一个是移除错误后排除缓存刷新疏漏的代码。最后，我们专门为 DDR4 使用了 TRResspass [14]，因为它使用的技术旨在绕过 DDR4 独有的防御机制。我们对这些仓库的更改详见附录 B。



**实验设置**
 我们在 Haswell i7-4770 CPU 上进行 DDR3 实验，运行 Ubuntu 18.04 和 Linux 内核版本 4.17.3。对于 DDR4 实验，我们使用 Coffee Lake i7-8700K CPU，运行 Ubuntu 20.04 和 Linux 内核版本 5.8.0。所有 DDR4 DIMM 的型号均为 M378A1K43BB2-CRC。

**结果**
 对于 DDR3，与修正地址错误的 Rowhammer.js 相比，我们的代码在最差情况下将翻转率提高了 248 倍，在最佳情况下提高了 525 倍。对于 TRRespass，我们发现修改代码以包含受害行缓存刷新后，DDR4 DIMM 的翻转率提升了 6 到 8 倍。
 虽然先前的 Rowhammer 研究报告了更高的翻转数 [8], [22]，但它们使用了通用设备上无法实现的技术。例如，[22] 的目标是了解 Rowhammer 在电路层面的脆弱性，因此使用 FPGA 测试 DIMM，消除了可能减少翻转数的高层干扰。同样，[8] 针对服务器进行翻转，其技术仅适用于多插槽系统。相比之下，我们使用的代码设计用于测试个人设备上的 Rowhammer 漏洞，并显示通过刷新受害行可以显著提高翻转数。

为了验证这些附加翻转是否确实源自缓存刷新，我们进行了额外实验，确认翻转数据是从内存而非缓存中获取的。这些实验的细节见附录 C。

**受害行缓存刷新对翻转率的影响**
 为了量化受害行缓存刷新对翻转率的具体影响，我们对现有代码进行了修订，添加了显式的受害行缓存刷新操作。表 I 中显示的实验结果表明，这种修订可以显著提高翻转检测率。我们还验证了翻转率的提升确实是由缓存刷新引起的，而不是其他因素导致的。这一验证步骤为进一步提高攻击成功率奠定了基础。

**对比现有技术的显著提升**
 在 DDR3 DIMM 上，我们的改进使翻转率提高了多个数量级，表明以往认为不易受攻击的硬件实际上可能极其脆弱。同样，在 DDR4 上，我们的实验显示，通过受害行缓存刷新可以有效绕过许多现有的 Rowhammer 防御机制，这些防御机制原本旨在减少翻转率。

**结论与展望**
 本研究通过对现有 Rowhammer 技术的关键改进，不仅大幅提高了翻转率，还揭示了在以往研究中被忽视的缓存问题。我们的研究表明，通过仔细调整测试方法，许多现有硬件比预期更加脆弱，这对未来硬件设计和安全研究提出了新的挑战。未来的工作将集中在以下方面：

1. 针对更多类型的硬件进行验证，以评估我们改进技术的普适性。
2. 开发针对高翻转率的自动化检测工具，为硬件制造商提供更精确的漏洞评估方法。
3. 探索更加高级的内存调整技术，以进一步提高攻击的成功率和精确性。

通过这些方向，我们希望能更全面地揭示现代硬件在 Rowhammer 攻击下的脆弱性，并推动硬件设计在安全性上的进步。

**翻译：**

在获得一个有用的、易受翻转的地址后，下一步是将受害变量强制放置在该地址上。目标受害变量是一个作为数组偏移量使用的变量。这类变量通常被分配为局部变量，因此位于受害者的栈上。因此，为了翻转这些变量并触发攻击，我们需要将受害者的栈放置在模板化步骤中获得的易受翻转的页面上。目前仅有一项先前的研究展示了栈调整的技术 [40]，且使用了（现已禁用的）页面去重机制。

需要注意的是，比特翻转对应于特定的 DRAM 地址，而这些地址是固定的物理地址。然而，物理地址可以通过页表映射到多个不同的虚拟地址。因此，目标是强制受害者使用特定的物理页面。此外，如果受害者位于内核代码中，攻击者需要调整内核栈，这比调整用户空间栈复杂得多，因为非特权攻击者无法直接操作内核页面。先前的研究已经展示了通过强制页表项 (PTE) 使用特定页面来调整内核内存的技术，但这些方法对内核栈调整来说过于不精确 [43]。现有技术仅仅是取消映射易受翻转的页面，然后用页表项填充物理内存，直到其中一个使用最近取消映射的页面。而对于内核栈调整，需要生成新线程以分配内核栈。由于生成新线程消耗资源，我们无法通过栈线程填充大部分内存，而必须通过内存操作将内存置于一种状态，从而最大化使用目标页面的概率。其他一些研究展示了更具确定性的技术，但它们特定于 Android [47]。

在本节中，我们开发了一种新技术，利用 Linux 的物理页面分配器“伙伴分配器”（详见附录 A）及其每 CPU（PCP）列表系统来调整内核内存。在描述我们的技术之前，我们提供了关于实现目标所操作的内存结构的背景知识。图 3 展示了概览。

### 内存区域（Memory Zones）

在伙伴分配器中，内存页面除了按顺序排序外，还按区域 (zone) 分类。区域表示物理地址的范围。每个区域都有一个特定的空闲页面水印。如果区域的总空闲内存低于水印，分配请求将转移到下一个优选区域。例如，一个进程可能请求 ZONE_NORMAL 的页面，但如果 NORMAL 区域的空闲页面不足，分配器将尝试从 ZONE_DMA32 服务请求 [15]。

### 页面顺序（Page Order）

在每个区域内，页面按块大小（即顺序）分组。一个顺序为 x 的块包含 2x2^x 个连续页面。分配器总是尝试从尽可能小的顺序中满足请求，但如果没有较小顺序的块可用，则会将较大的块一分为二，其中一部分用于满足请求 [15]。

### 迁移类型（Migrate-types）

页面进一步按照迁移类型 (migrate-type) 分类。迁移类型决定了页面在使用中时虚拟地址与物理地址的映射是否可以更改。例如，如果一个进程控制的虚拟页面映射到迁移类型为 MOVABLE 的物理页面，则可以通过将相同的虚拟地址重新映射到另一个物理地址来替换物理页面 [28]。

### PCP 列表（PCP Lists）

最后，PCP 列表（也称为页面帧缓存 (Page Frame Cache)）[6] 本质上是一个用于存储最近释放的顺序为 0 的页面的缓存。每个 CPU 对应一组按区域和迁移类型分类的先进后出列表。当有顺序为 0 的页面请求时，分配器首先尝试从对应的 PCP 列表中获取页面。如果列表为空，则从伙伴分配器的顺序为 0 的空闲列表中获取页面。当页面被释放时，它们始终被放置到相应的 PCP 列表中。即使一个较大的连续块被释放，每个单独的页面也会被放置在 PCP 列表中，只有当它们从 PCP 列表返回到伙伴分配器空闲列表时才会被合并。因此，该系统可以快速获取最近在同一 CPU 上释放的页面，而无需直接访问伙伴分配器。

通过深入理解这些内存结构，我们开发了一种有效的技术来操控内存分配器，以实现对内核栈的调整并触发所需的攻击。

**翻译：**

基于现有的用户空间调整技术 [6], [27]，主要目标是释放当前由攻击者持有的易受翻转页面，然后强制受害者的分配使用该刚刚释放的页面。在栈调整的情况下，这意味着强制进行一次新的栈分配。本节提出的技术遵循与现有工作 [6], [27] 类似的步骤。尽管以往的研究通过此过程调整由 `mmap` 分配的页面，但我们调整的是受害者的栈。

### 栈分配

用户空间的栈在创建新进程或线程时被分配，使用 `ZONE_NORMAL` 和迁移类型为 `MOVABLE` 的内存。此外，即使栈通常使用多个页面，该请求仍会以多个顺序为 0 的页面请求来处理，也就是说，页面从 PCP 列表中拉取。用户空间中通过 `mmap` 调用获取的页面也使用 `NORMAL` 和 `MOVABLE` 类型的内存，这意味着栈页面和受控的易受翻转页面类型相同。因此，通过 `unmap` 释放易受翻转页面后，该页面将被放置在与栈分配相同的 PCP 列表中。

### 调整步骤

在了解了 Linux 的栈分配机制后，栈调整可以通过以下步骤完成：

**步骤 1：填充分配**
 首先，我们进行“填充”分配，以抵消受害者在分配栈之前可能进行的任何分配。目标变量可能并不位于受害者栈的第一页上。因此，我们需要首先计算受害者在分配包含目标变量的栈页面之前将使用多少页面，并分配这些数量的填充页面。

**步骤 2：取消映射页面**
 接着，我们释放易受翻转页面，将其放入 PCP 列表中，然后释放填充页面，将它们放在相同列表中并位于易受翻转页面之上。

**步骤 3：受害者分配**
 最后，我们启动受害者进程，强制其执行预测的分配，包括目标栈的分配。在目标分配之前发生的任何分配都会从 PCP 列表中移除填充页面，从而强制栈使用目标页面。

### 结果

该技术的成功率约为 63%，这在实际应用中是可以接受的，因为只需要成功一次即可发起攻击。如果此步骤失败，我们可以重新尝试调整，并期望在两次尝试内成功。
 我们可以通过运行攻击的后续步骤（例如，调用包含恶意代码的受害者并锤击攻击行）并检查缓存侧信道中的数据来检测调整失败。如果未观察到任何数据，我们将重新尝试调整。

**翻译：**

### B. 内核空间栈调整

针对内核中的关键代码段（gadgets）同样需要强制栈变量使用特定的、易受翻转的页面。与用户空间栈分配类似，内核栈会在创建新线程或进程时分配，并由该线程或进程的所有系统调用使用。然而，与用户空间栈不同的是，内核栈使用 **UNMOVABLE** 内存，这意味着它从与用户空间 `mmap` 和 `unmap` 调用不同的 PCP 列表中获取页面。因此，攻击者需要一种方法来强制内核使用“用户页面”（**MOVABLE** 页面）而非“内核页面”（**UNMOVABLE** 页面）。我们从 Seaborn [43] 的研究中观察到，当内存压力较大时，内核确实会使用用户页面，并在 Seaborn 的技术基础上进一步改进，实现了更精确的内存调整技术，从而可以调整内核栈。

**分配器在内存压力下的行为**
 如前所述，当区域（zone）的空闲页面总数低于水印时，将使用下一个优选的区域。然而，由于区域包含多种迁移类型，可能会出现请求的迁移类型的空闲列表为空，但区域的总内存仍然高于水印的情况。在这种情况下，分配器会调用一个偷取函数，从特定的“回退”迁移类型中偷取页面，并将其转换为原本请求的类型。如图 4 所示，该函数尝试从回退类型中偷取最大的可用块。对于 **UNMOVABLE** 内存，第一个回退类型是 **RECLAIMABLE** 内存，第二个是 **MOVABLE** 内存。

### 内核调整步骤

内核栈调整所需的步骤与用户空间栈调整类似，关键区别在于攻击者必须首先施加内存压力，迫使内核使用用户页面。

#### **步骤 1：耗尽内核页面**

作为非特权攻击者，我们无法直接分配 **UNMOVABLE** 页面。然而，每次通过 `mmap` 进行分配时，都需要一个页表项（PTE）来映射虚拟页面和物理页面。由于 PTE 使用内核内存，每次 `mmap` 调用都会使用用户内存和内核内存。然而，多个 PTE 可以适配到单个页面中，并且 PTE 的地址取决于其对应的虚拟地址。我们需要进行足够大的分配，使每个 PTE 都需要一个新的页面，同时保持分配足够小，以免因分配过多内存而导致进程被杀死。将页面映射到 2MB 对齐的地址提供了最小的分配大小，从而确保每个 PTE 分配一个新页面。
 这些分配会一直进行，直到没有 **MOVABLE** 页面剩余，并使用 `pagetypeinfo` 文件监控剩余页面的数量。后续的映射将使用 **RECLAIMABLE** 页面来存储 PTE。一旦耗尽了必要的页面，下一次内核分配将使用最大的可用 **MOVABLE** 块。

对于无法访问 `pagetypeinfo` 文件的机器，我们改用 `buddyinfo` 文件（对于所有内核版本都是世界可读的）来监控 **MOVABLE** 和 **UNMOVABLE** 块的耗尽情况（同时执行步骤 1 和步骤 2），仅耗尽顺序为 4 或更高的 **UNMOVABLE** 块。（更详细的 `buddyinfo` 与 `pagetypeinfo` 的比较见附录 A。）

**翻译：**

### 步骤 2：耗尽用户页面

此时，内存已经处于一种状态，会迫使内核使用最大的可用 **MOVABLE** 块。然而，我们需要内核使用一个特定的页面（包含比特翻转的页面）。因此，我们需要确保目标页面位于这个块中。为了提高内核在栈分配中使用目标页面的概率，我们需要尽可能缩小最大的可用块的大小。因此，接下来的步骤是尽可能多地耗尽高阶空闲块，而不会使总空闲页面数量低于水印。在我们的实验中，我们能够耗尽所有顺序为 4 或更高的块。

### 步骤 3：释放目标页面

目标是释放目标页面，使其位于最大的可用块中。然而，释放此页面会将其发送到 PCP 列表，而不是伙伴分配器的空闲列表。即使它从 PCP 列表中释放，如果没有其他空闲页面作为“伙伴”，它将留在顺序为 0 的空闲列表中。释放的目标页面需要与其他页面合并，形成一个顺序为 4 的块，这样最大的剩余空闲块就包含了易受翻转的目标页面。幸运的是，如第 IV 节所述，我们已经确保目标页面是一个顺序为 4（或更高）块的一部分。因此，我们可以释放目标页面及其所有“伙伴”，以确保它会合并到最大的可用块中。

最后的障碍是 PCP 列表，因为即使释放一个连续的高阶块，所有页面也会被放入相应的 PCP 列表。然而，`zoneinfo` 文件显示了每个 PCP 列表中页面的数量以及每个列表的最大长度。在我们的实验机器上，最大长度为 186 页（根据 `zoneinfo` 文件）。因此，可以继续释放额外页面，直到 PCP 列表中的页面数量达到最大长度。这会强制页面从 PCP 列表中逐出并发送到伙伴分配器的空闲列表中，从而将目标页面置于 **MOVABLE** 内存的最大空闲块中。

### 步骤 4：分配内核栈

在释放目标页面并确保下一次内核栈分配使用用户内存后，我们现在可以强制进行内核栈分配。然而，释放页面以将目标页面从 PCP 列表中移出会稍微缓解内存压力，这意味着一些 **UNMOVABLE** 页面可能会重新变为空闲状态。内核栈分配将首先消耗这些页面，随后的分配会将包含目标页面的块转换为一个 **UNMOVABLE** 块。此外，由于内核的伙伴系统，该块会被一分为二，一半用于内核栈，另一半被移到较低阶的 **UNMOVABLE** 空闲列表中。目标页面可能位于任意一半，因此必须继续进行分配以确保目标页面被用于内核栈。

因此，我们使用内核栈喷洒（kernel stack spray）技术，通过分配多个内核栈来耗尽所有 **UNMOVABLE** 页面。我们通过生成许多线程进行栈喷洒。每个线程可以在一个空循环中运行，直到喷洒完成，然后逐个测试这些线程，让线程执行受害者的系统调用，并对目标变量进行锤击，直到观察到信息泄露。一旦找到使用目标页面的线程，其余线程将被释放。此时，我们就可以翻转位于内核栈中的栈变量。

### 结果

该技术使用 `pagetypeinfo` 方法的成功率约为 66%（使用 `buddyinfo` 方法为 60%）。通常情况下，期望在两次尝试内成功。

### **VI. 小工具利用（Gadget Exploitation）概述**

在成功将用户空间和内核空间的受害者栈指向易受翻转的地址后，可以通过翻转数组偏移值来触发错误预测，并泄露目标数据。为验证攻击效果，我们分别在用户空间和内核空间的示例受害者上演示了端到端的双小工具和三小工具攻击，证明了该方法能够泄露数据。

------

### **实验设置**

1. **双小工具攻击（Double Gadget Attack）**
   - 使用 Haswell i7-4770 CPU，运行 Ubuntu 18.04 和 Linux 内核版本 4.17.3。
   - DRAM 配置为一对三星 DDR3 4GiB DIMM。
2. **三小工具攻击（Triple Gadget Attack）**
   - 除 Haswell 外，还在以下处理器上测试：
     - Kaby Lake i7-7700
     - Coffee Lake Refresh i9-9900K
     - Comet Lake i7-10700K
   - 每台机器均配备 8GB DDR4 DIMM。
   - Linux 内核版本分别为 5.4.1、5.4.1 和 5.4.0。

**注**：

- **KASLR**（内核地址空间布局随机化）在所有机器上均启用。
- 默认启用了透明大页（THPs），可通过 `madvise` 系统调用分配。

------

### **A. 双小工具攻击 – 栈金丝雀泄露**

#### **栈金丝雀简介**

栈金丝雀是一种防御缓冲区溢出攻击的机制，它将一个特殊值（即金丝雀）放置在栈上，紧邻返回指针。如果攻击者试图通过缓冲区溢出覆盖返回指针，将导致金丝雀被篡改，进而触发程序中止。由于其低成本和有效性，栈金丝雀被广泛应用于防御栈溢出攻击。

#### **栈金丝雀的特性**

尽管栈金丝雀是随机生成的，但属于同一父进程的子进程会共享相同的栈金丝雀值。因此，如果泄露了某个子进程的金丝雀值，可以在同一父进程的其他子进程上实施缓冲区溢出攻击（假设目标程序存在内存漏洞）。

#### **示例攻击：OpenSSH**

例如，OpenSSH 使用单个守护进程生成多个子进程来处理加密。如果攻击者泄露了任意一个子进程的金丝雀值，就可以绕过其他子进程的防御，从而泄露加密密钥。

------

### **示例攻击：泄露栈金丝雀**

#### **攻击目标（Example Victim）**

- 攻击的目标是一个由攻击者生成的线程中的受害者代码，该代码包含一个双小工具（double gadget），如示例代码所示。
- 每个数组均为 `uint16_t` 类型，存储在攻击者和受害者共享的内存中，但通过 PRIME+PROBE 侧信道，也可以在没有共享内存的情况下发起攻击 [35]。
- 栈中包含机密金丝雀（stack canary）。如果金丝雀被修改，程序将终止执行。
- 由于受害者运行在攻击者生成的线程中，允许使用用户空间栈调整技术（stack massaging），这一方法也可以扩展到其他可强制生成的进程（如 OpenSSH [27]）。

------

#### **窃取栈金丝雀（Stealing Canaries）**

- 目标定位

  ：

  栈金丝雀位于受害者栈的末尾，紧接在目标数组之后，是双小工具攻击的理想目标。

  - 通过翻转数组偏移值的低位，可以使对应的数组访问超出数组末尾，指向栈金丝雀的位置。

- 栈金丝雀属性

  ：

  栈金丝雀通常为 32 至 64 位，存储在返回指针下方的地址中。

  - **Spectre v1 攻击**：每个恶意偏移值窃取一“字”的数据，其中“字”是指数组数据类型的大小。
  - 目标数组 `array1` 为 `uint16_t` 类型，每次翻转可以窃取 16 位数据，因此需要使用小工具 4 次，每次使用不同的恶意偏移值。

------

#### **触发目标翻转（Target Flip）**

- 目标翻转的要求

  ：

  Rowhammer 攻击需要将数组的偏移推到目标数组之外，指向栈金丝雀的位置。

  - 由于栈金丝雀分为多个“字”，可以通过以下两种方式实现翻转：
    1. 找到包含多个比特翻转的受害者行。
    2. 通过精确的时间控制，让受害者代码自然循环至目标偏移。
  - 我们选择第二种方法，因为在实验中包含多个翻转的行非常少见。

------

#### **内存模板和调整（Memory Templating and Massaging）**

- 按照第 IV 节的描述进行内存模板化，找到有效的比特翻转。
- 偏移变量位于栈中某个页面的特定偏移处，因此所需的翻转必须发生在相同的位置。
- **模板化时间**：大约 2.5 小时找到特定翻转。
- 释放包含翻转的页面，并生成受害者线程，强制其偏移变量使用易受翻转的页面。

------

#### **触发 Spectre 攻击（Triggering Spectre）**

1. **训练分支预测器**：
    让受害者线程以合法偏移值运行，训练分支预测器。

2. **偏移值的调整**：
    等待受害者线程将偏移设置为金丝雀目标字对应的值。

3. **同步执行**：
    攻击代码与受害者线程同步运行，也可使用 FLUSH+RELOAD 技术监控受害者代码的执行 [52]。

4. 诱导错误预测

   ：

   将偏移值逐出缓存，迫使小工具在错误预测的状态下使用翻转的偏移值。

   - 栈金丝雀的一部分作为偏移值被访问，加载到缓存中。
   - 使用 FLUSH+RELOAD 技术从缓存中提取目标数据。

5. **重复攻击**：
    等待偏移值改变后继续锤击，直至泄露完整的金丝雀值。

------

#### **泄露速率（Leakage Rate）**

- 每次攻击窃取 16 位（对应数组访问）。
- 泄露速率约为 **8b/s**，完整泄露栈金丝雀需要约 **8秒**，且准确率为 **100%**。

### **B. 三小工具攻击 – 内核任意读取**

#### **攻击目标**

该攻击示例演示如何利用内核系统调用中的三小工具（triple gadget）实现对内核内存的任意读取。这种攻击极其危险，因为内核内存是所有进程共享的，攻击者能够通过访问内核内存观察所有运行进程的数据。

- 示例受害者

  ：

  攻击目标是一个插入了三小工具的系统调用（syscall）。由于系统调用在内核特权下执行，内核中的任意数据均可能被泄露。

  - 攻击的目标数据是系统调用代码中一个 10 字符的字符串，该字符串位于目标数组之外的地址范围内。
  - 攻击者和受害者共享三小工具中使用的数组。

------

#### **内存模板化**

- 目标

  ：

  寻找一个有用的比特翻转，使受害者数组（在内核中）指向攻击者控制的数据。

  - 所需翻转是一个特定的高阶比特翻转，用于将受害者数组指向攻击者控制的内存区域。
  - 为减少找到翻转的时间，受害者被配置为允许数组偏移量位于栈中的任何位置（通过在每个偏移位置插入受害者变量实现）。这样无需寻找特定偏移处的翻转，只需在页面中任意对齐的 64 位字上找到特定比特翻转即可。

------

#### **攻击者控制的数据**

- 内存控制

  ：

  攻击者可通过在用户空间堆中分配大块内存并填充目标值，控制受害者地址空间中的数据。然而：

  - **内核地址空间布局随机化（KASLR）**：需要精确知道目标内核地址和控制用户地址之间的偏移。
  - **访问预防（SMAP）**：阻止内核读取用户内存，默认在现代 Intel 处理器上启用。

- 绕过 SMAP

  ：

  借鉴内核堆喷射攻击技术（heap spray attacks），通过调用如 

  ```
  sendmsg
  ```

   或 

  ```
  msgsnd
  ```

   的系统调用，将用户数据复制到内核地址中，并确保这些地址与目标翻转地址仅有一位之差。

  - 攻击者使用 `userfaultfd` 系统调用，通过挂起内核的页面故障处理，防止数据在返回前被释放，从而保持控制。

------

#### **插入栈数据**

- 栈喷射（stack spray）方法通过调用 `sendmsg` 等系统调用将用户定义的数据插入内核栈。
- 攻击者通过生成多个线程，并利用 `sendmsg` 插入栈数据，使数据地址与翻转目标地址仅一位之差，成功概率达 **87%**。

------

#### **控制页面偏移**

- 栈偏移对系统调用固定，因此攻击者需插入数据到页面内偏移与翻转目标匹配的地址中。
- 使用支持写入内核栈的多种系统调用（如 `sendmsg`，`recvmsg`），攻击者可在页面内滑动数据位置，确保偏移匹配目标。

------

#### **内核栈调整**

- 按照第 V-B 节的内核栈调整技术，强制系统调用使用包含比特翻转的页面作为数组偏移。
- 攻击者生成大量线程，检查每个线程是否使用目标页面。如果未找到目标页面，则重复模板化和调整步骤，直到目标页面落入内核栈。

------

#### **触发 Spectre 攻击**

1. **训练分支预测器**：让受害者线程合法运行循环偏移值，训练分支预测器。
2. **诱发错误预测**：定期锤击并逐出偏移值缓存，使小工具在错误预测状态下使用翻转的偏移值。
3. **侧信道泄露**：使用 FLUSH+RELOAD 确认受害者的字符串数据被泄露。
4. **重复攻击**：修改攻击者控制的数据，指向新的目标值，重复锤击以泄露下一个目标值。

------

#### **离线阶段性能**

- 在支持 

  ```
  pagetypeinfo
  ```

   且禁用 SMAP 的 Haswell 机器上：

  - 找到包含有用翻转的页面并使其进入内核栈平均需要 **34 分钟**。

- 使用 

  ```
  buddyinfo
  ```

   和 SMAP 绕过技术：

  - **降低翻转要求**：允许翻转从内核栈指向控制的内核栈区域，不再需要特定高阶比特翻转。
  - **时间缩短**：在所有测试机器上找到翻转并将其放入内核栈平均需要 **9 分钟**。

------

#### **泄露速率**

- DDR3

  ：

  - 每次错误预测泄露 8 位数据。
  - 泄露速率为 **16 至 24b/s**，以 100% 准确率泄露目标字符串。

- DDR4

  ：

  - 需要多侧锤击，单次锤击时间更长。
  - 泄露速率为 **4 至 19b/分钟**（平均 **6b/分钟**），同样以 100% 准确率泄露数据。
