### 一. 物理内存管理

早期操作系统（如MS-DOS）让程序直接访问何操作物理内存

缺点：无法进行多进程，执行完一条指令后，才能接着执行下一条

#### 1.连续分配存储管理

1. 单一连续存储管理

   在这种管理方式中，内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是，最简单，适用于单用户、单任务的操作系统。CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费；程序全部装入，使得很少使用的程序部分也占用—定数量的内存。

2. 分区式存储管理

   为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。

3. 伙伴系统

   固定分区方式限制了活动进程的数目，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对固定分区（单一连续存储管理）和动态分区两种内存方式的一种折衷方案。伙伴系统规定，无论已分配分区或空闲分区，其大小均为 2 的 k 次幂，k 为整数， l≤k≤m，其中：2^1 表示分配的最小分区的大小，2^m 表示分配的最大分区的大小。

4. 内存紧缩（内存碎片化处理)

   将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区。

   紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时。

   ![img](https://pic4.zhimg.com/v2-0da7cf91fc61a282f22a26860b390123_1440w.jpg)

5. 覆盖技术

   一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。

6. 交换技术(swapping)

   交换技术在多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），或读人保存在外存中而处于就绪状态的程序。交换单位为整个进程的地址空间。交换技术常用于多道程序系统或小型分时系统中，因为这些系统大多采用分区存储管理方式。与分区式存储管理配合使用又称作“对换”或“滚进／滚出” (roll-in／roll-out)。交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。

#### 2. 非连续分配（页式和段式存储管理）

如果允许将一个进程分散到许多不连续的空间，就可以避免内存紧缩，减少碎片。基于这一思想，通过引入进程的逻辑地址，把进程地址空间与实际存储空间分离，增加存储管理的灵活性。

1. 页式存储

   将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。页的大小式固定的，若程序需要的内存小于页，即程序只需要页中的一部分，剩余的未使用部分就会变成浪费的内存，这就是**内部碎片**。为了解决这个问题，现代操作系统通常会采用多级分页机制，即不仅使用固定大小的页，还允许在不同的内存范围内使用不同大小的页。例如，操作系统可以为小程序使用更小的页（如2KB、1KB或更小），而为大程序或数据使用更大的页（如8KB、16KB等）。这样可以减少小内存块的浪费。

   特点：

   + 没有外碎片，每个内碎片不超过页的大小
   + 一个程序不必连续存放。
   + 便于改变程序占用空间的大小
   + 要求程序全部装入内存，没有足够的内存，程序就不能执行。
   + 页大小固定且由系统决定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的。

   在页式系统中进程建立时，操作系统为进程中所有的页分配页框。当进程撤销时收回所有分配给它的页框。在程序的运行期间，如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。操作系统为了完成这些功能，必须记录系统内存中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。这就要求操作系统要记录每个进程页表的相关信息。为了完成上述的功能，—个页式系统中，一般要采用如下的数据结构。

   进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。

   每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序，如图：

   ![img](C:\Users\MIE\Desktop\主仓库\图片\v2-d4fe6620c6bc8a33b1f22e0ee91185b3_1440w.jpg)

2. 段式管理

   特点：

   + 段的长度不固定，且决定于用户所编写的程序，通常由编译系统在对源程序进行编译时根据信息的性质来划分。
   + 

3. 页式段式区别

   + 分页是信息的物理单位，分页是为了实现离散分配方式，以减少内存的碎片，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好地满足用户的需要。
   + 一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。
   + 逻辑地址表示：页式系统地址空间是一维的，即单一的线性地址空间，程序员只需利用一个标识符，即可表示一个地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。
   + 段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。

4. 段页式

#### 3. 虚拟地址

1. **可执行文件中的虚拟地址**：它们是程序的**预设虚拟地址**，由编译器和链接器在编译时确定。它们代表了程序在理想情况下应该加载到的虚拟内存位置。例如，链接器会将程序的代码段（`.text`）设定为加载到虚拟地址 `0x00400000`，数据段（`.data`）设定为加载到 `0x00600000`。

2. **程序执行时的虚拟地址**：这些地址是操作系统**实际分配的虚拟地址**，它们基于可执行文件中预设的虚拟地址，但可能会有所不同。例如，在现代操作系统中，由于 **地址空间布局随机化（ASLR）**，同一程序的不同实例可能会被加载到不同的虚拟地址空间位置，从而增强安全性。
   + **ASLR（Address Space Layout Randomization）**：一种安全技术，操作系统会在每次加载程序时，随机改变程序的加载地址。这意味着，即使两个进程加载相同的程序，它们的虚拟地址也会不同。即使是程序内部原本的虚拟地址（如 `0x00400000`），在不同运行时可能会被加载到不同的虚拟地址位置。
   + **x64dbg** 中看到的是 **ASLR（地址空间布局随机化）后**的虚拟地址，而 **IDA** 中显示的通常是 **编译后的虚拟地址**（即程序的原始虚拟地址）。





