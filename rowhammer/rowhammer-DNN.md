## 需解决的问题

1. 模型独立性(Model-independence)：最终影响推理结果的模型权重的确切位数的变化因模型而异，甚至对于同一模型在不同更新（例如微调）之间也会有所不同。在这种情况下，确定一个可以普遍应用于每个模型的位子集具有挑战性

   **解决方法**：论文提出通过修改底层通用代码库（如BLAS的线性代数后端）而非直接操作模型权重，从而实现对多种模型的普遍影响

2. 黑箱知识(Black-boxknowledge)：对于已经部署在服务器上的深度神经网络模型，在典型的机器学习即服务应用中，模型提供者通常只提供一个API接口来提供推理结果。因此，访问底层模型是不可行的。这种黑箱状况（不知道模型权重，甚至模型架构）使得错误位的识别几乎无法实现。

   **解决方法**：研究聚焦于主流机器学习框架（如TensorFlow、PyTorch）使用的通用库（如OpenBLAS），通过这些库的漏洞对所有依赖它们的模型实施攻击

3. 实际的单比特注入(Practicalsingle-bitinjection)：尽管在硬件中同时注入多个比特错误是可能的，但单比特注入在实际中更为可行。然而，在GC1和GC2的限制下，找到一个能够普遍影响未知模型的单一故障位似乎几乎不可能。三个技术挑战及解决方式如下：

   * 确定已识别库中的显著易损位，最终是一个显著位：通过遍历OpenBLAS库的cblas_dgemm函数并选择所有条件分支指令作为易损位候选来解决此问题。由于控制流的改变，分支指令对最终计算结果有重大影响。更具地说，对于每个易损候选位，操作其条件并将其切换到其他遍历路径。然后，通过评估翻转指令后的推理准确性，我们可以确定最易损的代码点，其效用恶化最严重。
   * 保持隐蔽性：注入的故障会干扰推理例程的控制流。除了期望的推理精度下降外，故障注入还可能导致系统警告通知或导致程序崩溃。为了隐蔽性，引入一种更可控的故障注入原语opflip，将一条指令的指令码翻转为其相邻指令的指令码，大多情况下，指令码中的位翻转会产生其他有效的指令。其中条件跳转令的一位相邻指令是具有完全相反语义的有效指令。通过用单个位故障破坏这种类型的指令，可以破坏深度神经网络推理计算的控制流，同时避免异常。因此，可以使得故障注入是隐蔽的。
   * 可行的注入故障的手段：为了切实可行，攻击者必须是一个无特权用户，在部署的服务器机器上访问受害模型，因此，不能通过物理/本地访问机器进行故障注入。因此利用Rowhammer攻击来操纵位于另一个进程地址空间中的代码页。由于Rowhammer能够翻转动态随机存取存储器中的位，已编译的机器学习代码库的翻转代码段位于页面缓存中。操作系统不会检测到这种变化，因为它是完全孤立的过程直接在硬件中进行的，




## 攻击者模型

1. 攻击者的目标：攻击者旨在通过向运行时机器学习代码库注入单个位错误来耗尽深度神经网络的推理效用，同时保持最大隐蔽性。注入的错误会干扰推理例程的正常控制流，导致推理准确性下降。

2. 系统方面：假设攻击者进程可以与目标深度神经网络服务共存，与受害者进程共享计算资源。攻击者是一个无特权用户，与受害者共享相同的物理内存。

3. 模型方面：不能访问网络架构、权重参数和一批测试数据。不对目标网络架构有先验知识。

4. 机器学习代码库方面：攻击者知道模型使用了哪些机器学习框架。主流的机器学习框架都得到了OpenBLAS库的支持，因此假设受害者使用了OpenBLAS。

5. 链接选项：假设受害者采用动态链接将目标文件链接到可执行输出文件中。





## 实现步骤

### 1.搜索脆弱比特位（vulnerablebits）

攻击者的目标是定位代码库中可能引发语义变化的敏感比特。具体过程如下：

* **确定攻击模块**:

  机器学习的代码库会调用各种共享库来支持其基本功能。其中名为GEMM的函数是基本线性代数子程序（BLAS）库的一部分，它使深度神经网络运行得更快、更节能。由于线性代数后端共享库不可或缺且被广泛采用，因此选择它作为攻击模块。

- **目标识别**：
  使用LLVM的自动漏洞指令搜索算法（AutoVIS），遍历代码库，定位指令集中跳转指令（如`je`、`jne`）及其他控制流指令。这些指令的操作码在位翻转后可能改变分支逻辑，从而影响程序执行路径。通过用单个位故障破坏跳转指令，可以破坏深度神经网络推理计算的控制流，同时避免异常。因此，故障注入是隐蔽的。
  
  ![image-20250116160939857](C:\Users\MIE\AppData\Roaming\Typora\typora-user-images\image-20250116160939857.png)
  
- **自动化搜索工具**：
  使用AutoVIS工具。LLVM编译过程可以简要地分为三个阶段，即编程代码、中间表示（IR）和机器级指令。AutoVIS会检查每一个传入的中间表示（IR），筛选出条件分支指令，并通过更改分支条件来修改分支。该插件帮助我们生成修改后的BLAS库，其中恰好有一个分支条件被恶意修改。修改后的库与深度神经网络模型链接。如果这个修改后的库实现了最佳的攻击性能（最大效用降级，既无警告也无崩溃），则相应的分支指令就会被选为目标条件分支。

------

### 2.Rowhammer技术的应用

- **内存分析**：
  
  采用了Rowhammer-test工具来分析DDR3芯片，并使用TRRespass来分析DDR4芯片。内存分析的结果是一个在物理内存中可翻转的位位置的列表（即候选可翻转页面）。攻击者首先进行离线内存分析，识别出目标脆弱指令所在的虚拟页，并将其与包含可翻转存储单元的物理页进行匹配。
  
- **内存映射破解**：
  破解虚拟地址到物理地址的映射，利用内存分配算法的特性（如伙伴分配器）迫使内核分配物理上连续的内存，从而定位目标物理行。
  
- **内存篡改（MemoryMassage）**：
  利用内存拦截技术将易受攻击的虚拟页面重新定位到在上一步中发现的匹配物理页面上。内存拦截是在页面缓存中的页面上执行的。由于这些缓存页面随时可以被淘汰，并被视为可用内存。从动态随机存取存储器（DRAM）中移除后，页面缓存页面在访问时会被随机重新定位。持续的淘汰最终会将易受攻击的页面放置在攻击者期望的物理位置上。一旦将易受攻击的位填充到DRAM的可翻转位中，攻击者就开始初始化两个攻击行来锤击中间的受害行。攻击者触发目标位翻转，这种变化会立即在受害方生效。在随后的访问中， 页面缓存中受影响的库会持续提供给受害方。



## 故障注入防御措施

#### 1. Deep-Dyve

使用一个简化且更小的深度神经网络（称为检查器深度神经网络）来近似原始复杂深度神经网络模型（称为任务深度神经网络）的输出。随后， 该方法以端到端的方式验证这两个模型的输出一致性。 如果检查器模型的输出和任务模型的输出不匹配，则会对任务深度神经网络进行重新计算，以实现潜在的故障恢复。

#### 2. 基于硬件的防御措施

需要对底层硬件进行修改，包括内存控制器和DRAM

#### 3. 基于软件的防御措施

利用 Rowhammer 攻击的 特定特征来检测相关攻击，对DRAM和内存控制器进行修改以检测位翻转，并使用所提出的指令集扩展由操作系统来纠正翻转的位。

#### 4. 阻止内存劫持

内存劫持使得攻击者能够精确地操纵内存分配，这种技术对于发动攻击至关重要。操作系统可以监控页面缓存页 面的异常活动，并限制单个进程中过多的页面缓存页面的分配，以阻止攻击的进行

#### 5.保护关键指令 

通过系统软件对最易受攻击的位进行选择性保护，可以有效地减轻攻击。具体而言，通过利用所提出的 AutoVIS，可以识别出显著降低深度神经网络准确性的脆弱指令，并随后通过安全隔区（secure enclave）对其进行保护。

