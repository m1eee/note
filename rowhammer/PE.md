![img](C:\Users\MIE\Desktop\主仓库\图片\b4ec24bb03667ae30eb8599b7a547681.jpeg)

![img](C:\Users\MIE\Desktop\主仓库\图片\3a18d0544efcf37bb51479d3601e64c8.jpeg)

![img](C:\Users\MIE\Desktop\主仓库\图片\aa71d668ff4438d171b0158e6765f68f.png)

## 1. PE 文件

### 1.1概述

PE（Portable Executable）文件是 Windows 系统下可执行文件的总称。常见的 PE 文件类型包括：

- **DLL**（动态链接库）
- **EXE**（可执行文件）
- **OCX**（ActiveX 控件）
- **SYS**（系统驱动程序）

PE 文件最初是为了提高程序在不同操作系统上的移植性而设计的，但实际上，这种文件格式仅用于 Windows 系列操作系统。

需要注意的是，PE 文件的类型与文件的扩展名无关。即一个文件是否为 PE 文件与其扩展名（如 `.exe`、`.dll` 等）无关。PE 文件可以有任何扩展名。

### 1.2 PE 文件执行和在内存中的加载

1. 当一个 PE 文件 被执行时，**PE 装载器** 首先检查 DOS header 里的 PE header 的偏移量。如果找到，则直接跳转到 PE header 的位置。
2. 当 PE装载器 跳转到 PE header 后，第二步要做的就是检查 PE header 是否有效。如果该 PE header 有效，就跳转到 PE header 的尾部。
3. 紧跟 PE header 尾部的是节表。PE装载器执行完第二步后开始读取节表中的节段信息，并采用文件映射（ 在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射的机制，也就是说，**Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系，只有真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存**，这种机制使文件装入的速度和文件大小没有太大的关系 ）的方法将这些节段映射到内存，**同时附上节表里指定节段的读写属性**。
4. PE文件映射入内存后，PE装载器将继续处理PE文件中类似 import table（输入表）的逻辑部分。

### 1.3 **相对虚拟地址RVA**与虚拟地址VA

​    一个 PE 文件被加载到内存中以后，称之为 " 映象 "（image），**一般来说，PE文件在硬盘上和在内存里是不完全一样的**，**被加载到内存以后其占用的虚拟地址空间要比在硬盘上占用的空间大一些**，**这是因为各个节在硬盘上是连续的，而在内存中是按页对齐的，所以加载到内存以后节之间会出现一些 “空洞” 。**

因为存在这种对齐，所以在 PE 结构内部，表示某个位置的地址采用了两种方式：

1. 针对在硬盘上存储文件中的地址，称为 **原始存储地址** 或 **物理地址**，表示**距离文件头的偏移**。
2. 针对加载到内存以后映象中的地址，称为 **相对虚拟地址（RVA），表示相对内存映象头的偏移**。

## 2. 重定位

### 2.1 重定位概念

在编程中，程序代码通常会根据某个特定的内存地址进行编译，称为**相对地址**（或**逻辑地址**）。例如，编译后的目标程序（obj 文件）中的地址默认是基于一个虚拟地址空间为“0”的。多个目标模块通过连接程序（linker）合并成一个完整的装配模块。装配模块虽然有一个统一的地址空间，但它依然以“0”作为参考地址，意味着这个地址是浮动的。

当程序被加载到内存时，操作系统需要确定装入内存的实际物理地址，并修改代码中与地址有关的部分，这个过程被称为**地址重定位**。换句话说，地址重定位是将程序的相对地址映射到其实际内存地址的过程。

### 2.2 重定位类型

重定位有两种主要类型：**静态重定位**和**动态重定位**。

------

## 3. 静态重定位

### 3.1 静态重定位概述

**静态重定位**是在程序执行之前进行的重定位。它通过修改目标模块中的地址指令，使其适应装配模块实际加载到内存中的位置。为支持静态重定位，连接程序在生成统一地址空间和装配模块时，应产生一个**重定位项表**，连接程序此时还不知道装配模块将要装入的实际位置，故重定位表所给出的需修改位置是相对地址所表示的位置。

静态重定位的过程如下：

1. **生成重定位项表**：连接程序在生成统一地址空间的装配模块时，还会生成一个重定位项表。该表列出了所有需要修改的地址（即重定位项）。
2. **修改指令**：由于连接程序无法知道装配模块的实际内存地址，因此它在生成时使用相对地址。操作系统在加载时，将实际起始地址与重定位项表结合，计算出每个需要修改的地址。

### 3.2 静态重定位过程

1. 操作系统加载装配模块时，得到实际装入的起始地址。
2. 对重定位项表中的每一项，计算重定位因子（即实际装入地址与相对地址的差值）。
3. 对需要修改的指令，执行如下步骤：
   - 取出重定位项；
   - 将重定位因子加到该项中，以得到实际地址；
   - 更新指令中的地址。

### 3.3 静态重定位优缺点

**优点**：

- 不需要硬件支持。

**缺点**：

- 重定位后的程序无法在内存中移动。如果程序需要搬迁，必须重新进行重定位。
- 程序的存储空间需要是连续的，不能分布在多个不连续的内存区域。

------

## 4. 动态重定位

### 4.1 动态重定位概述

动态重定位不同于静态重定位，它不是在程序执行之前进行重定位，而是在程序执行过程中进行。具体来说，动态重定位是在 CPU 每次访问内存单元之前进行地址变换。

### 4.2 动态重定位过程

1. **装入目标模块**：目标模块装入内存时，地址有关的各项均保持原来的相对地址不进行任何修改。如MOV　1，[500]这条指令仍是相对地址500。
2. **设置定位寄存器**：操作系统将目标模块的实际装入地址减去目标模块的相对基地址，计算出偏移量，并将其存入定位寄存器。
3. **动态地址转换**：当 CPU 访问内存时，硬件将指令中的相对地址与定位寄存器中的值相加，计算出实际的内存地址，然后访问该地址的数据。

### 4.3 动态重定位的优缺点

**优点**：

- 目标模块装入内存时无需修改，因此可以方便地进行内存搬迁而不影响程序的正常执行。
- 程序的各个目标模块可以不连续地存储在内存中，只要每个模块都有对应的定位寄存器即可。这对解决内存碎片问题非常有利。

**缺点**：

- 需要硬件的支持，特别是定位寄存器和硬件地址转换逻辑。
